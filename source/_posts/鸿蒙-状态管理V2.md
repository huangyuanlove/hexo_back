---
title: 鸿蒙-状态管理V2
tags: [HarmonyOS]
date: 2025-02-08 17:12:02
keywords: HarmonyOS,鸿蒙应用开发,鸿蒙手机应用开发,状态管理,@ObservedV2,@ComponentV2,@Local,@Param,@Once,@Event,@Monitor,@Computed,@Type
---


## 前言

前面我们讲了状态管理V1相关装饰器和注意事项，一般来讲是足够在开发中使用了，但还是有一些不方便的地方，因此又有了状态管理 V2。
截止到现在，V2的指南中已经移除了 gap提示，说明已经稳定可用。官方也希望我们尽快做迁移，当然，将来会不会出 V3 那就不得而知了。

## 综述

V2 版本的状态管理装饰器有以下几种，都是从api12开始支持。不过问题不大，目前应用市场上架鸿蒙应用最低版本要求就是api12

* @ComponentV2装饰器：自定义组件
* @ObservedV2装饰器和@Trace装饰器
* @Local装饰器：组件内部状态
* @Param：组件外部输入
* @Once：初始化同步一次
* @Event装饰器：规范组件输出
* @Provider装饰器和@Consumer装饰器：跨组件层级双向同步
* @Monitor装饰器：状态变量修改监听
* @Computed装饰器：计算属性
* @Type装饰器：标记类属性的类型

### @ComponentV2
和V1中的@Component装饰器一样，@ComponentV2装饰器用于装饰自定义组件：只有在该装饰器修饰的类中才能使用，也仅能使用其他V2版本的状态管理装饰器，无法在同一个自定义组件中混用V1、V2装饰器

``` TypeScript
@ComponentV2 // 装饰器
struct Index { // struct声明的数据结构
  build() { // build定义的UI
  }
}
```

### @ObservedV2和@Trace
先来看下这两个，后续介绍其他装饰器时有用到。
这两个装饰器被用来做深度观测，也就是嵌套类的变化。在 V1 版本中，我们使用`@Observed`和`@ObjectLink`来实现，但有一个问题就是无法进行嵌套观测，只能观测当前层级的属性变化。V2 版本的这两个装饰器配合使用，可以实现跨嵌套层级观测。

``` TypeScript
@ObservedV2
class Person {
  @Trace name: string = ''
  @Trace age: number = 0
  @Trace address:Address = new Address()
}

@ObservedV2
class Address{
  @Trace zipCode : string = '000000'
  @Trace city:string = '北京'
}
```
定义一个嵌套类，使用`@ObservedV2`装饰需要观测的类，并且在类中使用`@Trace`修饰每一个需要参与UI绘制的属性。当需要观测的类和属性较多时，写起来就比较恶心了。还有一点：@ObservedV2的类实例目前不支持使用JSON.stringify进行序列化。




### @Local
该装饰器修饰的变量**只能**在本地初始化，不能由外部传入，目的是能更好的表示组件内部的状态，不会被外部传入参数影响。
和`@State`相比，它无法观察到class对象属性的赋值，仅能观察到对象的整体赋值，也就是说它的观测能力仅限于被装饰变量的本身。
当需要观察class对象属性的变化时，需要使用`@ObservedV2`和`@Trace`装饰器。
有一点需要注意的地方：在状态管理V2中，会给使用状态变量装饰器如@Trace、@Local装饰的Date、Map、Set、Array添加一层代理用于观测API调用产生的变化，因此我们在取其中的值进行比较时，需要使用`UIUtils.getTarget()`获取原始对象进行比较。
``` TypeScript
list: string[][] = [['a'], ['b'], ['c']];
@Local strList: string[] = this.list[0];
@Monitor("strList")
onStrChange(monitor: IMonitor) {
    hilog.error(0x01, '@Local', 'strList has changed')
}

build() {
    Column() {
          Button('修改为同一个对象').onClick(() => {

        if (this.strList !== this.list[0]) {
          hilog.error(0x01, '@Local', '重新赋值')
          this.strList = this.list[0];
        }
      })
      Button('修改为同一个对象').onClick(() => {

        if (UIUtils.getTarget(this.strList) !== this.list[0]) {
          hilog.error(0x01, '@Local', '重新赋值')
          this.strList = this.list[0];
        }
      })
    }
}
```
这里我们定义了一个二维数组，同时将数组第一项赋值给被`@Local`修饰的变量，同时使用`@Monitor`观察该变量的变化。
当我们点击第一个按钮时，发现控制台会打印`重新赋值`和`strList has changed`。当我们点击第二个按钮时，控制台没有打印。

### @Param

可以从父组件传入，也可以在本地初始化，如果配合`@Require`使用，则父组件必须传入该参数，此时本地初始化的值将被覆盖。
有一点需要注意：不能在组件内部直接修改变量本身，但可以修改类对象的属性;如何类对象属性**没有**被`@Trace`修饰，修改类对象属性也不会引起 UI 刷新
当我们在组件内部直接修改变量本身时，则会提示`Cannot assign to 'count' because it is a read-only property.`

![修改@Param变量报错提示](image/HarmonyOS/修改@Param变量报错提示.png)


### @Once

如果想要直接在组件内修改被`@Param`修饰的变量本身，可以配合`@Once`，但是，但是，但是，被`@Once`装饰的变量仅能在外部初始化一次，当在外部修改该变量本身时，不会同步到子组件。看下示例
