---
title: 鸿蒙-那些年我们踩过的坑-下
tags: [HarmonyOS]
date: 2024-11-11 15:33:33
keywords: HarmonyOS,鸿蒙应用开发,plain (literal) objects,class (constructor) objects,CustomDialogController
---
书接上回，在上一篇文章中介绍了 ForEach循环渲染和自绘制输入框遇到的坑，这里聊一下 字面量对象和类对象 以及 自定义 Dialog 的坑。
<!--more-->


先从简单的Dialog 开始，这里没有很深入的讲解，只是一些注意点以及官方推荐用法

## CustomDialogController

先说结论：在使用`CustomDialog`和`CustomDialogController`做自定义弹窗时，`CustomDialogController`可以作为被`@Entry`修饰的struct的成员变量，可以作为被`@Component`修饰的自定义组件的成员变量，甚至可以写在组件的点击事件中，但不能写到单纯的方法中

### 示例
正常情况：

``` TypeScript
@Entry
@Component
struct DialogControllerPage {
  @State message: string = 'Hello World';
  dialogID: number = 0
  dialogController: CustomDialogController | null = new CustomDialogController({
    builder: CustomDialogExample({
      cancel: () => {
      },
      confirm: () => {
      },
    }),
  })
  build() {
    Column() {
      Text('在 Click 事件中定义').margin(10)
        .fontSize(30)
        .fontWeight(FontWeight.Bold)
        .onClick((_) => {
          let dialogController: CustomDialogController | null = new CustomDialogController({
            builder: CustomDialogExample({
              cancel: () => {
              },
              confirm: () => {
              },
            }),
          })
          dialogController.open()
        })
      
      //在自定义组件中定义
      CustomDialogView()

      Text('在页面中定义').margin(10)
        .fontSize(30)
        .fontWeight(FontWeight.Bold)
        .onClick((_) => {
          this.dialogController?.open()
        })
    }
  }
}
@Component
struct CustomDialogView{
  dialogController: CustomDialogController | null = new CustomDialogController({
    builder: CustomDialogExample({
      cancel: () => {
      },
      confirm: () => {
      },
    }),
  })
  build() {
    Text('在自定义组件中定义').margin(10)
      .fontSize(30)
      .fontWeight(FontWeight.Bold)
      .onClick((_) => {
        this.dialogController?.open()
      })
  }
}
```
上面的这三种情况都是可以正常弹出弹窗的，但当我们把`CustomDialogController`写在普通方法中时

``` TypeScript
export function showDialog() {
  let dialogController: CustomDialogController | null = new CustomDialogController({
    builder: CustomDialogExample({
      cancel: () => {
      },
      confirm: () => {
      },
    }),
  })
  dialogController.open()
}

```
这里会报一个错误，应用会崩溃，报错信息挺长的，这里截取了一部分
> Pid:25224
Uid:20020185
Process name:com.huangyuanlove.arkui_demo
Process life time:47s
Reason:Signal:SIGSEGV(SEGV_MAPERR)@0x00000000000008b0  probably caused by NULL pointer dereference
Fault thread info:
Tid:25224, Name:love.arkui_demo
#00 pc 00000000029cfd70 /system/lib64/platformsdk/libace_compatible.z.so(OHOS::Ace::Framework::JSCustomDialogController::JsOpenDialog(OHOS::Ace::Framework::JsiCallbackInfo const&)+8)(1a64ce74d582cc151101042697df670d)
#01 pc 00000000009a8cb0 /system/lib64/platformsdk/libace_compatible.z.so(panda::Local<panda::JSValueRef> OHOS::Ace::Framework::JsiClass<OHOS::Ace::Framework::JSCustomDialogController>::InternalJSMemberFunctionCallback<OHOS::Ace::Framework::JSCustomDialogController>(panda::JsiRuntimeCallInfo*)+2148)(1a64ce74d582cc151101042697df670d)
#02 pc 00000000004dc50c /system/lib64/platformsdk/libark_jsruntime.so(panda::Callback::RegisterCallback(panda::ecmascript::EcmaRuntimeCallInfo*)+456)(3499a0e0c3b8b8dc50b1a4589295965e)

我想这可能就是为啥需要在`@CustomDialog`修饰的 struct 中声明一个`CustomDialogController`变量的原因。

### 官方推荐方案
在官方文档中有一个 [不依赖UI组件的全局自定义弹窗 (推荐)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-uicontext-custom-dialog-V5)。虽然说是**不依赖UI组件**，但实际上还是使用的UIContext这个上下文获取到`promptAction`，调用`promptAction.openCustomDialog`方法来实现的弹窗。
吐槽归吐槽，先看下用法，看完了再评价也不迟。
这里有两种方案，一种是传入`ComponentContent`对象，这个方案在 [不依赖UI组件的全局自定义弹窗 (推荐)](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-uicontext-custom-dialog-V5)这里有详细介绍
另外一种方案是传入` promptAction.CustomDialogOptions`,这种方案是在[@ohos.promptAction (弹窗)](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-promptaction-V5) API 参考中介绍的。

#### 传入`ComponentContent`对象

  
