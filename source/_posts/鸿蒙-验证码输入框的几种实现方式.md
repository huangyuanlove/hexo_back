---
title: 鸿蒙-验证码输入框的几种实现方式
tags: [HarmonyOS]
date: 2024-09-10 17:57:30
keywords: HarmonyOS,鸿蒙应用开发,鸿蒙手机应用开发,TextInput,验证码输入框
---

最近在做应用鸿蒙化，说白了就是把原来`Android`、`iOS`的代码重新用`ArkTS`写一遍，我负责基础建设和登录模块，有个验证码输入框需要定制一下外观样式。这里详细记录一下探索过程及结果，以及思路和源码。这里给出了三种方案
一：多个 InputText 拼接，每个 InputText 只能输入 1 个字符，代码控制焦点移动，
二：多个 Text 拼接，通过系统api`inputMethod.InputMethodController`控制键盘弹起并记录输入内容，刷新到 Text 中展示
三：使用 Canvas 自己绘制。
由于篇幅较长，这个拆成两篇来介绍。本篇介绍前两种方式，也是最常见的方式。使用Canvas 自己绘制纯粹就是闲着写的东西，后面再介绍。

<!-- more -->

## 效果图、优缺点
先放一下效果图
<div>
<img src='/image/HarmonyOS/verification_code/four_text_input.gif' width='30%' heigh='30%'/>
<img src='/image/HarmonyOS/verification_code/four_text.gif' width='30%' heigh='30%'/>
<img src='/image/HarmonyOS/verification_code/canvas_input.gif' width='30%' heigh='30%'/>
</div>

#### 多TextInput
**优点**：只需要控制焦点就好，键盘的弹起、收起以及输入的内容我们不需要自己去监听，并且除了边框颜色之外，输入框内会有光标闪烁，也能给用户更强一些的提示
**缺点：需要控制没有获取到焦点的输入框不能点击、不能长按等。尝试多种方案**(设置 enable、focusable 等)均失败后，决定在输入框上面覆盖一个空白透明且大小和输入框相等的 Text 解决这个问题。有其他方案可以告诉我一下

#### 多 Text
**优点**：不用控制焦点，只需要使用变量控制一下样式就好
**缺点**：需要自己记录键盘输入的文字，并且没有光标闪烁，当前也可以自己搞个 gif 图或者写个动画来模拟光标

#### Canvas 绘制
**优点**：我真的没想到有啥优点，可以自由的绘制边框、底色也算么？但现在的 pai 中有各种各样的Modifier来修改各种属性，实现自己绘制
**缺点**：全都得自己画，挺麻烦的

## 多个 TextInput 拼接
这里用四位验证码做例子：
思路挺简单的，四个`TextInput`并排放一块，输入框限制输入 1 个字符，用`Flex`做父控件也行，用`Row`做父控件也行,无所谓，这不是重点。
组件刚出现时，使用`getUIContext().getFocusController().requestFocus(key:string)`将焦点放在第一个输入框上，键盘就可以弹出来
监听`TextInput`的`onDidDelete`和`onChange`或者`onDidInsert`事件，来判断下一个焦点放在哪个位置
当最后一个`TextInput`有输入字符时，认为输入完成，进行回调。

下面详细介绍一下每一步怎么做的，以及对应的想法

### 放置四个输入框

当前获取到焦点的输入框颜色要明亮一些，没有焦点的输入框颜色要暗淡一些。我们使用`@Extend()`做一个公用样式，传入当前是否是焦点控件来控制边框颜色

``` TypeScript
@Extend(TextInput)
function textInputStyle(enable:boolean){
  .border({
    width: 1,
    color: enable?"#1b91e0":"#999999",
    radius: 4,
    style: BorderStyle.Solid,
  }).textAlign(TextAlign.Center)
  .layoutWeight(1)
  .maxLength(1)
  .maxLines(1)
  .type(InputType.Number)
  .layoutWeight(1).height(40)
}
```
为了在焦点变化的时候输入框背景能同步修改，这里用一个`@State`修饰的布尔数组表示哪个输入框获取焦点。同时为了省事，也定义了另外一个数组，方便使用 `ForEach`循环渲染。定义另外一个字符串数组来记录每个输入框的内容
``` TypeScript
@State inputValue: string[] = ["", "", "", ""]// 输入框的内容
@State inputEnable: boolean[] = [true, false, false, false] //输入框是否获取焦点
inputIndex: number[] = [0, 1, 2, 3] //ForEach渲染用
  build() {
    Row() {//这里用 Flex 更方便一些，直接设置间距就好，不用这样设置 margin 了
      ForEach(this.inputIndex, (index: number) => {
        TextInput({ text: this.inputValue[index] })
          .id(index.toString())//这里 id 是给FocusController使用
          .margin({ right: index == this.inputIndex.length - 1 ? 0 : 10 })
          .textInputStyle(this.inputEnable[index])
      })
    }
  }
```
这样我们就画出来了最基本的布局。但我们会发现进入页面后键盘不能自己弹出来，因为输入框没有获取到焦点。
这里有两个方案，一个是给其中`TextInput`设置`defaultFocus`为 true，或者在页面展示的时候设置焦点
``` TypeScript
TextInput({ text: this.inputValue[index] }).defaultFocus(this.inputEnable[index])
//或者
Row(){}.onAppear(()=>{this.getUIContext().getFocusController().requestFocus("0")})
```
注意这里`requestFocus()`方法传入的参数`"0"`,也就是上面`TextInput`的`id`的值.
这样我们就做好的基本的属性，并且页面显示的时候也可以弹出键盘了。
![](image/HarmonyOS/verification_code/four_textinput_base.png)

### 焦点移动

#### 输入时向后移动
但是这时候我们点击键盘输入的时候，发现光标并不会自动移动到下一个输入框上继续输入。这里需要我们进行控制。这个也比较简单，`TextInput`有一个输入内容发生变化时，触发的回调：`onChange(callback: EditableTextOnChangeCallback)`。我们可以在这个方法里面移动焦点

``` TypeScript
TextInput().onChange((value: string, previewText?: PreviewText) => {
this.inputValue[index] = value //记录输入的内容
if (value.length == 1) { //确认是输入而不是删除
    if (index != 3) {//如果不是最后一个输入框发生的输入事件，就把焦点交给下一个输入框
    this.inputEnable[index+1] = true//记录下一个输入框获取焦点，改变背景色
    this.getUIContext().getFocusController().requestFocus((index + 1).toString())//下一个输入框获取焦点
    this.inputEnable[index] = false//标记当前输入框失去焦点，改变背景色
    } else {//如果是最后一个输入框发生的输入事件，表示已经输入完了，继续后面流程
    //todo 输入完成，继续后面流程
    }
}
})
```

#### 输入完成回调
这就很简单了，定义一个函数变量，接收父布局传进来的函数，输入完成时回调这个函数就好

``` TypeScript
onFinishInput?: (value: string) => void  //函数变量
//输入完成，进行回调
if (this.onFinishInput) {//判断一下空值，然后把保存的值拼接成字符串回调
    let result = ""
    for (let i = 0; i < this.inputValue.length; i++) {
        result += this.inputValue[i]
    }
    this.onFinishInput(result)
}
```
到这里，我们已经实现了大部分功能：输入字符、保存字符、焦点向后移动、输入完成时回调。
下面要解决的就是删除

#### 删除时向前移动
